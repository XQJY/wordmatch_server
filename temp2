/*
** http-server.c
*/

#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <strings.h>
#include <sys/select.h>
#include <sys/sendfile.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <time.h>

// constants
static char const * const HTTP_200_FORMAT = "HTTP/1.1 200 OK\r\n\
Content-Type: text/html\r\n\
Content-Length: %ld\r\n\r\n";
static char const * const HTTP_200_FORMAT_COOKIE = "HTTP/1.1 200 OK\r\n\
Content-Type: text/html\r\n\
Content-Length: %ld\r\n\
Set-Cookie: sessionID = %ld\r\n\r\n";
static char const * const HTTP_400 = "HTTP/1.1 400 Bad Request\r\nContent-Length: 0\r\n\r\n";
static int const HTTP_400_LENGTH = 47;
static char const * const HTTP_404 = "HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\n\r\n";
static int const HTTP_404_LENGTH = 45;
static char const * const NAME_HTML = "<p>Welcome, %s!</p>";
static int const NAME_HTML_LENGTH = 17;
static int const FIRST_PLAYER = 4;
static int const SECOND_PLAYER = 5;
static int const RETRY_FROM = 6;

// represents the types of method
typedef enum
{
    GET,
    POST,
    UNKNOWN
} METHOD;

typedef enum{
    GET_INTRO,
    POST_NAME,
    GET_START,
    POST_QUIT,
    POST_GUESS,
    INVALID,
    RETRY
}type;

typedef enum{
    WELCOME,
    READY,
    GAME,
    END
}status;

typedef struct request{
    bool dynamic;
    type reqType;
    char* value;
} req;

typedef struct cookie{
    long sessionID;
    char* username;
}cookie;

//static variables
static cookie* cookieLib[10];
static int currCookie = 0;

static int uniqueID(int session){
    int i;
    for(i = 0; i < 10; i++){
        if (cookieLib[i] != NULL){
            if(cookieLib[i]->sessionID = session) return false;
        }
    }
    return true;
}

//generate a cookie, return the sessionID
static long generateCookie(char* username){
    int index;
    long sessionID;

    if(currCookie < 10) {
        index = currCookie;
        cookieLib[index] = (cookie*) malloc(sizeof(cookie));
    }
    else {
        index = currCookie % 10;
        free(cookieLib[index]->username);
    }

    do{
        sessionID = rand();
    }while(uniqueID(sessionID));

    cookieLib[index]-> sessionID = sessionID;
    cookieLib[index]-> username = malloc(sizeof(username));
    memcpy(cookieLib[index]-> username, username, sizeof(username));
}

static req* parseRequest(char* buff, int sockfd){
    req* temp = malloc(sizeof(req));
    char * curr = buff;
    METHOD method = UNKNOWN;

    // parse the method
    if (strncmp(curr, "GET ", 4) == 0)
    {
        curr += 4;
        method = GET;
    }
    else if (strncmp(curr, "POST ", 5) == 0)
    {
        curr += 5;
        method = POST;
    }
    else if (write(sockfd, HTTP_400, HTTP_400_LENGTH) < 0)
    {
        perror("write");
        return NULL;
    }

    // sanitise the URI
    while (*curr == '.' || *curr ==
                           '/')
        ++curr;

    // parse the type and the value of the request
    if(method == GET) {
        if (strncmp(curr, "?start=Start ", 13) == 0) {
            temp->dynamic = false;
            temp->reqType = GET_START;
            temp->value = NULL;
        } else {
            temp->dynamic = false;
            temp->value = GET_INTRO;
            temp->value = NULL;
        }
    }

    else if(method == POST){
        if((curr = strstr(buff,"quit=Quit")) != NULL){
            temp->dynamic = false;
            temp->reqType = POST_QUIT;
            temp->value = NULL;
        } else if((curr = strstr(buff,"guess=")) != NULL){
            temp->dynamic = true;
            temp->reqType = POST_GUESS;
            temp->value = curr + 6;
        } else if((curr = strstr(buff,"user=")) != NULL){
            temp->dynamic = true;
            temp->reqType = POST_NAME;
            temp->value = curr + 5;
        } else {
            temp->dynamic = false;
            temp->reqType = INVALID;
            temp->value = NULL;
        }
    }

    else {
        temp->dynamic = false;
        temp->reqType = INVALID;
        temp->value = NULL;
    }

    return temp;
}

static bool response_static_request(type t, int sockfd){
    char* html;
    if(t == GET_INTRO){
        html = "1_intro.html";
    } else if(t == GET_START){
        html = "3_first_turn.html";
    } else if (t == POST_QUIT){
        html = "7_gameover.html";
    } else if (t == RETRY){
        html = "8_retry.html";
    }
    char buff[2049];
    int n;
    struct stat st;
    stat(html, &st);
    n = sprintf(buff, HTTP_200_FORMAT, st.st_size);
    if (write(sockfd, buff, n) < 0)
    {
        perror("write");
        return false;
    }
    // send the file
    int filefd = open(html, O_RDONLY);
    do{
        n = sendfile(sockfd, filefd, NULL, 2048);
    }
    while (n > 0);
    if (n < 0)
    {
        perror("sendfile");
        close(filefd);
        return false;
    }
    close(filefd);
    return true;
}

static bool response_dynamic_request(req* r, int sockfd){
    int n;
    int move_from;
    char* html;
    char* insertion;
    long added_length;
    char buff[2049];
    if(r->reqType == POST_NAME){
        html = "2_start.html";
    } else return false;

    // get the size of the file
    struct stat st;
    stat(html, &st);
    // increase file size to accommodate the username

    long size;
    //Calculate the addedLength
    if(r->reqType == POST_NAME){
        long randID = generateCookie(r->value);
        added_length = strlen(r->value) + NAME_HTML_LENGTH;
        size = st.st_size + added_length;
        n = sprintf(buff, HTTP_200_FORMAT_COOKIE, size, randID);
    }

    //n = sprintf(buff, HTTP_200_FORMAT, size);
    // send the header first
    if (write(sockfd, buff, n) < 0)
    {
        perror("write");
        return false;
    }
    // read the content of the HTML file
    int filefd = open(html, O_RDONLY);
    n = read(filefd, buff, 2048);
    if (n < 0)
    {
        perror("read");
        close(filefd);
        return false;
    }
    close(filefd);
    // move the trailing part backward

    if(r->reqType == POST_NAME){
        move_from = ((int) (strstr(buff, "\n<form method=\"GET\">") - buff));
        insertion = (char*) malloc(sizeof(char) * added_length);
        sprintf(insertion, NAME_HTML, r->value);
    }

    int p1, p2;
    for (p1 = size - 1, p2 = p1 - added_length; p2 >= move_from; --p1, --p2)
        buff[p1] = buff[p2];
    ++p2;

    // put the separator

    strncpy(buff + p2, insertion, added_length);
    free(insertion);

    if (write(sockfd, buff, size) < 0)
    {
        perror("write");
        return false;
    }
    return true;
}

static bool handle_http_request(int sockfd)
{
    // try to read the request
    char buff[2049];
    int n = read(sockfd, buff, 2049);
    if (n <= 0)
    {
        if (n < 0)
            perror("read");
        else
            printf("socket %d close the connection\n", sockfd);
        return false;
    }

    // terminate the string
    buff[n] = 0;

    req * request;

    // return the failure
    if((request = parseRequest(buff,sockfd)) == NULL){
        return false;
    }

    if(sockfd >= RETRY_FROM) {
        request -> reqType = RETRY;
        request-> dynamic = false;
    }

    if (request->reqType == INVALID){
        fprintf(stderr, "no other methods supported");
        if (write(sockfd, HTTP_404, HTTP_404_LENGTH) < 0)
        {
            perror("write");
            free(request);
            return false;
        }
    } else if (request->dynamic == false){
        if(!response_static_request(request->reqType, sockfd)){
            free(request);
            return false;
        }
    } else {
        if(!response_dynamic_request(request, sockfd)){
            free(request);
            return false;
        }
    }

    free(request);
    return true;
}

int main(int argc, char * argv[])
{
    srand (time(NULL));

    if (argc < 3)
    {
        fprintf(stderr, "usage: %s ip port\n", argv[0]);
        return 0;
    }

    // create TCP socket which only accept IPv4
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // reuse the socket if possible
    int const reuse = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
    {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    // create and initialise address we will listen on
    struct sockaddr_in serv_addr;
    bzero(&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    // if ip parameter is not specified
    serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
    serv_addr.sin_port = htons(atoi(argv[2]));

    // bind address to socket
    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // listen on the socket
    listen(sockfd, 5);

    // initialise an active file descriptors set
    fd_set masterfds;
    FD_ZERO(&masterfds);
    FD_SET(sockfd, &masterfds);
    // record the maximum socket number
    int maxfd = sockfd;

    while (1)
    {
        // monitor file descriptors
        fd_set readfds = masterfds;
        if (select(FD_SETSIZE, &readfds, NULL, NULL, NULL) < 0)
        {
            perror("select");
            exit(EXIT_FAILURE);
        }

        // loop all possible descriptor
        for (int i = 0; i <= maxfd; ++i)
            // determine if the current file descriptor is active
            if (FD_ISSET(i, &readfds))
            {
                // create new socket if there is new incoming connection request
                if (i == sockfd)
                {
                    struct sockaddr_in cliaddr;
                    socklen_t clilen = sizeof(cliaddr);
                    int newsockfd = accept(sockfd, (struct sockaddr *)&cliaddr, &clilen);
                    if (newsockfd < 0)
                        perror("accept");
                    else
                    {
                        // add the socket to the set
                        FD_SET(newsockfd, &masterfds);
                        // update the maximum tracker
                        if (newsockfd > maxfd)
                            maxfd = newsockfd;
                        // print out the IP and the socket number
                        char ip[INET_ADDRSTRLEN];
                        printf(
                                "new connection from %s on socket %d\n",
                                // convert to human readable string
                                inet_ntop(cliaddr.sin_family, &cliaddr.sin_addr, ip, INET_ADDRSTRLEN),
                                newsockfd
                        );
                    }
                }
                    // a request is sent from the client
                else if (!handle_http_request(i))
                {
                    close(i);
                    FD_CLR(i, &masterfds);
                }
            }
    }

    return 0;
}